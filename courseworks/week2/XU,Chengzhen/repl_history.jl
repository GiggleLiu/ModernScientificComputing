# time: 2023-03-04 17:43:53 CST
# mode: julia
	boolean variables
# time: 2023-03-04 17:43:58 CST
# mode: julia
	# boolean variables
# time: 2023-03-04 17:44:10 CST
# mode: julia
	ture isa Bool
# time: 2023-03-04 17:44:18 CST
# mode: julia
	true isa Bool
# time: 2023-03-04 17:45:02 CST
# mode: julia
	# size in bytes (1 byte = 8bits)
# time: 2023-03-04 17:45:24 CST
# mode: julia
	sizeof(Bool)
# time: 2023-03-04 17:45:27 CST
# mode: julia
	# not
# time: 2023-03-04 17:45:32 CST
# mode: julia
	!ture
# time: 2023-03-04 17:45:37 CST
# mode: julia
	!true
# time: 2023-03-04 17:45:40 CST
# mode: julia
	# and
# time: 2023-03-04 17:45:47 CST
# mode: julia
	true && false
# time: 2023-03-04 17:45:52 CST
# mode: julia
	# or
# time: 2023-03-04 17:45:57 CST
# mode: julia
	true || false
# time: 2023-03-04 17:46:04 CST
# mode: julia
	true
# time: 2023-03-04 17:46:21 CST
# mode: julia
	# xor: type \xor<TAB>
# time: 2023-03-04 17:47:17 CST
# mode: julia
	exit()
# time: 2023-03-04 17:47:31 CST
# mode: julia
	# boolean variables
# time: 2023-03-04 17:47:38 CST
# mode: julia
	true isa Bool
# time: 2023-03-04 17:47:58 CST
# mode: julia
	# size in btypes (1 btype 8 bits)
# time: 2023-03-04 17:48:05 CST
# mode: julia
	sizeof(Bool)
# time: 2023-03-04 17:48:18 CST
# mode: julia
	# not
# time: 2023-03-04 17:48:21 CST
# mode: julia
	!ture
# time: 2023-03-04 17:48:26 CST
# mode: julia
	!true
# time: 2023-03-04 17:48:29 CST
# mode: julia
	# and
# time: 2023-03-04 17:48:37 CST
# mode: julia
	true && false
# time: 2023-03-04 17:48:41 CST
# mode: julia
	# or
# time: 2023-03-04 17:48:46 CST
# mode: julia
	true || false
# time: 2023-03-04 17:49:00 CST
# mode: julia
	# xor: type \xor<TAB>
# time: 2023-03-04 17:49:55 CST
# mode: julia
	true false
# time: 2023-03-04 17:50:10 CST
# mode: julia
	true \xor<TAB> false
# time: 2023-03-04 17:50:31 CST
# mode: julia
	\xor<TAB>
# time: 2023-03-04 17:51:38 CST
# mode: julia
	\xor<tab>
# time: 2023-03-04 17:52:15 CST
# mode: julia
	ture ⊻ false
# time: 2023-03-04 17:52:20 CST
# mode: julia
	true ⊻ false
# time: 2023-03-04 17:55:30 CST
# mode: julia
	3 isa Int
# time: 2023-03-04 17:55:50 CST
# mode: julia
	0x3 usa UInt8
# time: 2023-03-04 17:55:58 CST
# mode: julia
	0x3 isa UInt8
# time: 2023-03-04 17:56:12 CST
# mode: julia
	bitstring(3)
# time: 2023-03-04 17:56:24 CST
# mode: julia
	bitstring(0x3)
# time: 2023-03-04 17:56:37 CST
# mode: julia
	sizeof(3)
# time: 2023-03-04 17:56:44 CST
# mode: julia
	sizeof(0x3)
# time: 2023-03-04 17:57:15 CST
# mode: julia
	7 % 3
# time: 2023-03-04 17:57:43 CST
# mode: julia
	7 / 3
# time: 2023-03-04 17:57:53 CST
# mode: julia
	7 ÷ 3
# time: 2023-03-04 17:59:11 CST
# mode: julia
	7 << 1
# time: 2023-03-04 17:59:14 CST
# mode: julia
	7 >> 1
# time: 2023-03-04 17:59:18 CST
# mode: julia
	7 | 1
# time: 2023-03-04 17:59:52 CST
# mode: julia
	7 & 1
# time: 2023-03-04 18:00:13 CST
# mode: julia
	7 ⊻ 1
# time: 2023-03-04 18:00:52 CST
# mode: julia
	3.2 isa Float64
# time: 2023-03-04 18:00:59 CST
# mode: julia
	3.2e2 isa Float64
# time: 2023-03-04 18:01:13 CST
# mode: julia
	3.2f2 isa Float32
# time: 2023-03-04 18:01:27 CST
# mode: julia
	3.2 + 3im isa ComplexF64
# time: 2023-03-04 18:01:55 CST
# mode: julia
	typeof(π)
# time: 2023-03-04 18:02:48 CST
# mode: julia
	typeof(ℯ)
# time: 2023-03-04 18:02:58 CST
# mode: julia
	3.0 ^ 3
# time: 2023-03-04 18:03:18 CST
# mode: julia
	"3.0" isa String
# time: 2023-03-04 18:03:30 CST
# mode: julia
	(1,"3.0") isa Tuple
# time: 2023-03-04 18:03:59 CST
# mode: julia
	(1,"3.0")[1]
# time: 2023-03-04 18:04:13 CST
# mode: julia
	(3.0=>"3.0") isa Pair
# time: 2023-03-04 18:04:37 CST
# mode: julia
	(3.0=>"3.0").first
# time: 2023-03-04 18:04:42 CST
# mode: julia
	(3.0=>"3.0").second
# time: 2023-03-04 18:05:13 CST
# mode: julia
	# vector
# time: 2023-03-04 18:05:23 CST
# mode: julia
	[2,3.0] isa Vector
# time: 2023-03-04 18:05:27 CST
# mode: julia
	# range
# time: 2023-03-04 18:05:42 CST
# mode: julia
	1:10 isa UnitRange # 1,2...,10
# time: 2023-03-04 18:05:48 CST
# mode: julia
	length(1:10)
# time: 2023-03-04 18:06:08 CST
# mode: julia
	1:2:10 isa StepRange
# time: 2023-03-04 18:06:14 CST
# mode: julia
	# dick
# time: 2023-03-04 18:06:18 CST
# mode: julia
	# dict
# time: 2023-03-04 18:06:42 CST
# mode: julia
	d = Dict(3.0=>"three",4.0=>"four")
# time: 2023-03-04 18:07:12 CST
# mode: julia
	d isa Dict
# time: 2023-03-04 18:07:24 CST
# mode: julia
	# keys, and values of a dict
# time: 2023-03-04 18:07:29 CST
# mode: julia
	keys(d)
# time: 2023-03-04 18:07:35 CST
# mode: julia
	values(d)
# time: 2023-03-04 18:07:56 CST
# mode: julia
	# get dict element
# time: 2023-03-04 18:08:02 CST
# mode: julia
	d[3.0]
# time: 2023-03-04 18:08:27 CST
# mode: julia
	# Using `get`, you can set the default value
# time: 2023-03-04 18:08:38 CST
# mode: julia
	get(d,3.0,"not exist")
# time: 2023-03-04 18:08:43 CST
# mode: julia
	get(d,5.0,"not exist")
# time: 2023-03-04 18:09:12 CST
# mode: julia
	# use `haskey` to check whether a key exists
# time: 2023-03-04 18:09:20 CST
# mode: julia
	haskey(d,3.0)
# time: 2023-03-04 18:09:32 CST
# mode: julia
	# types can be used for conversion
# time: 2023-03-04 18:09:49 CST
# mode: julia
	UInt64(3) isa UInt64
# time: 2023-03-04 18:10:20 CST
# mode: julia
	Float32(3) isa Float32
# time: 2023-03-04 18:13:43 CST
# mode: julia
	# vectors and tuples can be created using splatting:`some_iterable...`
# time: 2023-03-04 18:13:55 CST
# mode: julia
	[(1,"3.0"...)]
# time: 2023-03-04 18:14:03 CST
# mode: julia
	[(1,"3.0")...]
# time: 2023-03-04 18:14:26 CST
# mode: julia
	([1,3.0]...,)
# time: 2023-03-04 18:14:45 CST
# mode: julia
	((3.0=>"3.0")...,)
# time: 2023-03-04 18:14:54 CST
# mode: julia
	(1:2:10...,)
# time: 2023-03-04 18:15:13 CST
# mode: julia
	[1:2:10...]
# time: 2023-03-04 18:15:49 CST
# mode: julia
	[Dict(3.0=>"three",4.0=>"four")...]
# time: 2023-03-04 18:15:58 CST
# mode: julia
	# equibalently
# time: 2023-03-04 18:16:02 CST
# mode: julia
	# equivalently
# time: 2023-03-04 18:16:09 CST
# mode: julia
	collect(1:2:10)
# time: 2023-03-04 18:16:17 CST
# mode: julia
	# the range of types
# time: 2023-03-04 18:16:37 CST
# mode: julia
	typemin(Int)
# time: 2023-03-04 18:16:52 CST
# mode: julia
	typemax(Int)
# time: 2023-03-04 18:17:07 CST
# mode: julia
	typemin(Float64)
# time: 2023-03-04 18:17:10 CST
# mode: julia
	typemax(Float64)
# time: 2023-03-04 18:17:23 CST
# mode: julia
	# the zero and one element of types
# time: 2023-03-04 18:17:30 CST
# mode: julia
	zero(Float64)
# time: 2023-03-04 18:17:37 CST
# mode: julia
	one(Float64)
# time: 2023-03-04 18:17:49 CST
# mode: julia
	0.0 * Inf
# time: 2023-03-04 18:18:04 CST
# mode: julia
	Inf == Inf
# time: 2023-03-04 18:18:11 CST
# mode: julia
	NaN == NaN
# time: 2023-03-04 18:18:42 CST
# mode: julia
	# precision of floating point numbers(floating point number distance at 1.0)
# time: 2023-03-04 18:18:53 CST
# mode: julia
	eps(Float32)
# time: 2023-03-04 18:18:59 CST
# mode: julia
	eps(Float64)
# time: 2023-03-04 18:19:16 CST
# mode: julia
	# rounding error is unbiquitus in floating point numbers
# time: 2023-03-04 18:19:32 CST
# mode: julia
	1.0 == nextfloat(1.0)
# time: 2023-03-04 18:20:39 CST
# mode: julia
	# we prefer using `≈` in many practical using cases
# time: 2023-03-04 18:20:50 CST
# mode: julia
	1.0 ≈ nextfloat(1.0)
# time: 2023-03-04 18:21:01 CST
# mode: julia
	#### Arbitary precision #####
# time: 2023-03-04 18:21:07 CST
# mode: julia
	# numbers can overflow
# time: 2023-03-04 18:22:13 CST
# mode: julia
	let # let creates a local scope
	    x=1
	    for i=1:100 # iterates over 1,2,...,100
	        x *= i
	    end
	    x # the (implicitly) returned value
	end
# time: 2023-03-04 18:22:34 CST
# mode: julia
	# BigInt uses arbitary precision, it avoids overflow
# time: 2023-03-04 18:23:04 CST
# mode: julia
	let 
	    x = BigInt(1)
	    for i=1:100
	        x *= 1
	    end
	    x
	end
# time: 2023-03-04 18:23:17 CST
# mode: julia
	let 
	    x = BigInt(1)
	    for i=1:100
	        x *= i
	    end
	    x
	end
# time: 2023-03-04 18:23:30 CST
# mode: julia
	### control flows ###
# time: 2023-03-04 18:23:36 CST
# mode: julia
	# block statement
# time: 2023-03-04 18:23:56 CST
# mode: julia
	# block statement is trivial, it is just a sequence of operations
# time: 2023-03-04 18:24:10 CST
# mode: julia
	a=0; a += 1; a += 2;a
# time: 2023-03-04 18:24:27 CST
# mode: julia
	# or equivalently
# time: 2023-03-04 18:24:56 CST
# mode: julia
	begin # the begin statement does create a local scope
	    a=0
	    a +=1
	    a+=2
	    a
	end
# time: 2023-03-04 18:25:10 CST
# mode: julia
	# for statement
# time: 2023-03-04 18:25:23 CST
# mode: julia
	# the following two statements are the same
# time: 2023-03-04 18:26:05 CST
# mode: julia
	for i in 1:3
	    #println is print + <LINEBREAK>
	    println(i)
	end
# time: 2023-03-04 18:26:32 CST
# mode: julia
	# declare a variable without initialization
# time: 2023-03-04 18:27:14 CST
# mode: julia
	let
	    for i =1:3
	        j = i==1 ? 1 : j + 1
	    end
	    j
	end
# time: 2023-03-04 18:28:05 CST
# mode: julia
	let
	    local jfor i =1:3
	        j = i==1 ? 1 : j + 1
	    end
	    j
	end
# time: 2023-03-04 18:28:36 CST
# mode: julia
	let 
	    local j # declared without initialization
	    for i = 1:3
	        j=i==1?1:j+1
# time: 2023-03-04 18:29:04 CST
# mode: julia
	let 
	    local j # declared without initialization
	    for i = 1:3
	        j = i == 1 ? 1 : j + 1
	    end
	    j
	end
# time: 2023-03-04 18:29:21 CST
# mode: julia
	# using global variables
# time: 2023-03-04 18:29:29 CST
# mode: julia
	global_j = 0
# time: 2023-03-04 18:30:13 CST
# mode: julia
	let 
	    for i=1:5
	        global_j += 1# cannot access global variables at a local scope
	    end
	end
# time: 2023-03-04 18:30:47 CST
# mode: julia
	let 
	    for i=1:5
	        global global_j += 1 # this one works
	    end
	end
# time: 2023-03-04 18:30:56 CST
# mode: julia
	global_j
# time: 2023-03-04 18:31:29 CST
# mode: julia
	# sepcial Note: unlike the let statement, the block statment runs in the current scope instead of creating a local one.
# time: 2023-03-04 18:31:35 CST
# mode: julia
	# if statemen
# time: 2023-03-04 18:31:38 CST
# mode: julia
	# if statement
# time: 2023-03-04 18:32:04 CST
# mode: julia
	# we can use if statement to find out all prime numbers
# time: 2023-03-04 18:32:08 CST
# mode: julia
	using Primes
# time: 2023-03-04 18:32:52 CST
# mode: julia
	for i=1:typemax(Int8)
	    if isprime(i)
	        println(i)
	    end
	end
# time: 2023-03-04 18:33:20 CST
# mode: julia
	# while statement
# time: 2023-03-04 18:34:28 CST
# mode: julia
	let i=Int8(0)
	    while i < typemax(Int8)
	        i += Int8(1)
	        if prime(i)
	            println(i)
	        end
	    end
	end
# time: 2023-03-04 18:34:47 CST
# mode: julia
	let i=Int8(0)
	    while i < typemax(Int8)
	        i += Int8(1)
	        if isprime(i)
	            println(i)
	        end
	    end
	end
# time: 2023-03-04 18:35:10 CST
# mode: julia
	create a UnitRange for all positive Int8 numbers
# time: 2023-03-04 18:35:13 CST
# mode: julia
	# create a UnitRange for all positive Int8 numbers
# time: 2023-03-04 18:35:28 CST
# mode: julia
	ints = Int8(1):typemax(Int8)
# time: 2023-03-04 18:35:55 CST
# mode: julia
	# create boolean vector for indexing using broadcasting operation:`.`
# time: 2023-03-04 18:36:14 CST
# mode: julia
	boolean_mask = isprime.(ints)
# time: 2023-03-04 18:36:46 CST
# mode: julia
	# the locations marked with 1 will be collected to a vector
# time: 2023-03-04 18:36:54 CST
# mode: julia
	ints[boolean_mask]
# time: 2023-03-04 18:37:22 CST
# mode: julia
	# even shorter, you can use list comprehension
# time: 2023-03-04 18:37:56 CST
# mode: julia
	[x for x in Int8(1)Ltypemax(Int8) if isprime(x)]
# time: 2023-03-04 18:38:11 CST
# mode: julia
	[x for x in Int8(1):typemax(Int8) if isprime(x)]
# time: 2023-03-04 18:38:36 CST
# mode: julia
	# or even shorter with filter
# time: 2023-03-04 18:38:57 CST
# mode: julia
	filter(isprime, Int8(1):typemax(Int8))
# time: 2023-03-04 18:39:36 CST
# mode: julia
	# check the docstring of filter with the `@doc` macro
# time: 2023-03-04 18:39:43 CST
# mode: julia
	@doc filter
# time: 2023-03-04 18:40:07 CST
# mode: julia
	# if ... elseif ... else ... end
# time: 2023-03-04 18:41:44 CST
# mode: julia
	function compare(x,y)
	    if x<y
	        relation = "less than"
	    elseif x==y
	        relation = "equal to"
	    else
	        relation = "larger than to"
	    end
	    println("$x is $relation $(y).")
	end
# time: 2023-03-04 18:41:51 CST
# mode: julia
	compare(3, 4)
# time: 2023-03-04 18:42:04 CST
# mode: julia
	# error handling
# time: 2023-03-04 18:42:17 CST
# mode: julia
	# try ... catch ... finally ... end
# time: 2023-03-04 18:42:41 CST
# mode: julia
	try
	    x=[1]
	    x[0] # Julia conts from 1!
	catch 3
# time: 2023-03-04 18:44:05 CST
# mode: julia
	try
	    x=[1]
	    x[0] # Julia conts from 1!
	catch e
	    @info "get error $e" # @info is a fancy way of printing
	    throw(e)
	finally
	    println("I will be executed anyway ;D")
	end
